---
title: "Introduction to fragquaxi"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{overview}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
options(dplyr.summarise.inform = FALSE)
```

The `fragquaxi` package allows you to obtain **fr**actional **a**bundances of **g**lycoforms (and proteoforms in general) from mass spectrometric (MS) data by **qua**ntification *via* **X**IC (extracted ion current) **i**ntegration. 

```{r setup, message = FALSE}
library(dplyr)
library(ggplot2)
library(purrr)
library(tidyr)
library(mzR)
library(fragquaxi)
```



# Molecular formulas

This package provides an S3 class `mol_form` that represents molecular formulas. Such a formula is created by `molecular_formula()`:

```{r}
emtansine <- molecular_formula("C35 H48 Cl1 N3 O10 S1")
emtansine
```

Spaces separating individual elements are optional, as are counts with value 1. Hence, the following function calls will return identical formula objects:

```{r}
molecular_formula("C35 H48 Cl1 N3 O10 S1")

molecular_formula("C35 H48 Cl N3 O10 S")

molecular_formula("C35H48ClN3O10S")
```

Element counts may be negative or marked by an explicit plus sign:

```{r}
molecular_formula("N-1 H-3")      # Gln -> pyroglutamate

molecular_formula("P+1 O+3 H+1")  # phosphorylation
```

Note how the order of elements in the printed output complies with the Hill system.

```{r}
molecular_formula("Cl4 C")

molecular_formula("H12 C6 O6")
  
molecular_formula("H2SO4")
```

`molecular_formula()` is vectorized: If called with a string vector, it returns a vector of formulas.

```{r}
molecular_formula(c("H2 O", "C6 H12 O6"))
```

Formulas support elementary arithmetic operations. (In case of multiplication and division, the numeric multiplier is always coerced to integer in order to ensure that element counts remain integral. Moreover, division is always integral.)

```{r}
f1 <- molecular_formula("C6 H10 O5")
f2 <- molecular_formula("C5 H11 NO2 S")
f1 + f2

f1 - f2

f1 * 2L

f1 * 2.9  # multiplier implicitly converted to the integer 2L

f1 / 2    # equivalent to f1 %/% 2L

sum(c(f1, f2))
```

`get_mass()` calculates the molecular mass of a formula:

```{r}
molecular_formula("C6 H10 O5") %>% get_mass()
```

By default, `get_mass()` uses average atomic masses. However, the package also provides monoisotopic masses:

```{r}
molecular_formula("C6 H10 O5") %>% get_mass(mass_set = "monoisotopic")
```

The dataset `atomic_masses` provides these average and monoisotopic masses:

```{r}
atomic_masses
```

`new_mass_set()` allows you to define custom mass sets:

```{r}
my_masses <- new_mass_set(c(H = 10, C = 100, O = 1))
molecular_formula("C6 H8 O5") %>% get_mass(my_masses)
```

In order to avoid missing values in custom mass sets, you may choose to inherit masses from a previously defined set *via* the argument `inherits_from`:

```{r}
my_masses_complete <- new_mass_set(
  c(H = 10, C = 100, O = 1),
  inherits_from = "average"
)
molecular_formula("H2 S O4") %>% get_mass(my_masses)

molecular_formula("H2 S O4") %>% get_mass(my_masses_complete)
```

`charge()` converts a molecular mass to a mass-to-charge ratio:

```{r}
charge(150000, z = 20:24)
```

`charge()` naturally works with masses calculated for molecular formulas:

```{r}
molecular_formula("C6464 H9950 N1706 O2014 S44") %>%
  get_mass() %>%
  charge(20:24)
```



# Prepare data for quantification

Prepare data for quantification in three steps: (1) Define proteins; (2) define PTM compositions; (3) assemble proteoforms and calculate their masses; and (4) select ions to be quantified.

## (1) Define proteins

`define_proteins()` loads protein sequences in FASTA format and obtains their formulas. Each FASTA file must contain one record for each protein chain (so that the formula reflects the correct number of chain termini). In addition, indicate the number of disulfide bridges (if any) *via* the optional argument `.disulfides`.

```{r}
mab_sequence <- system.file(
  "extdata", "mab_sequence.fasta",
  package = "fragquaxi"
)

proteins <- define_proteins(
  mab = mab_sequence,
  .disulfides = 16
)

proteins
```

The resulting *protein specification* is a data frame that describes one protein per row and comprises three columns: `protein_name`, protein names derived from the argument names in `define_proteins()`; `protein_data`, a nested column that stores the FASTA file name and number of disulfides; and `protein_formula`, the formula calculated from the amino acid sequence, taking into account the numbers of disulfides and chains.


## (2) Define PTM compositions

`fragquaxi` is tailored towards analysis of *proteoforms*, *i.e.*, the different molecular forms in which the protein product of a single gene can be found due to changes introduced by posttranslational modifications (PTMs). In the context of this package, proteoforms are described by their PTM compositions (or *modcoms* in short):

```{r}
ptm_compositions <- tribble(
  ~modcom_name, ~Hex, ~HexNAc, ~Fuc, ~PHOS, ~foo,
  "G0F/G0",        6,       8,    1,     0,    0,
  "G0F/G0F",       6,       8,    2,     0,    0,
  "G0F/G1F",       7,       8,    2,     0,    0,
  "G1F/G1F",       8,       8,    2,     0,    0,
  "G1F/G2F",       9,       8,    2,     0,    0,
  "G2F/G2F",      10,       8,    2,     0,    0,
  "G2F/G2F+P",    10,       8,    2,     1,    0,
  "G2F/G2F+foo",  10,       8,    2,     0,    1,
)
```

In this data frame, each row corresponds to the PTM composition of a single proteoform. The first column must be labeled `modcom_name` and should contain a short description. The remaining columns must be labeled by valid PTM names (see below) and contain the number of the respective PTM found in the respective composition.

The table above describes a range of proteoforms that differ in *N*-glycosylation, phosphorylation (`PHOS`) and “fooylation” (`foo`). Glycosylation is described in terms of the overall monosaccharide composition of the *N*-glycans; consequently, the data frame includes the columns `Hex`, `HexNAc`, and `Fuc` to indicate the number of hexose, *N*-acetylhexosamine, and fucose residues, respectively.

Valid PTM names include

* monosaccharides as provided in the data set `monosaccharides`:

    ```{r}
    monosaccharides
    ```

* PTMs as provided in the data set `ptms`:

    ```{r}
    ptms
    ```

* other PTMs that must be defined in terms of their correction formula:

    ```{r}
    my_ptms <- c(
      foo = "C42",  # so this is fooylation!
      bar = "H-42"
    )
    ```

`define_ptm_compositions()` creates a modcom specification from these PTM compositions and custom PTMs (if required):

```{r}
modcoms <- define_ptm_compositions(ptm_compositions, other_ptms = my_ptms)
modcoms
```

The resulting *modcom specification* is a data frame that describes one PTM composition per row and comprises three columns: `modcom_name` (same column as in the input data frame); `modcom_data`, a nested column that contains the remaining columns from the input data frame; and `modcom_formula`, the correction formula associated with the respective PTM composition.


## (3) Assemble proteoforms and calculate their masses

Once all proteins and modcoms have been specified in this way, `assemble_proteoforms()` combines them and calculates the masses of the resulting proteoforms:

```{r}
pfm_masses <- assemble_proteoforms(proteins, modcoms)

pfm_masses
```

Combining $p$ proteins with $m$ modcoms yields a data frame that describes $p \times m$ proteoforms and comprises four columns: `protein_name` and `modcom_name`, which together uniquely identify a proteoform; `formula`, its molecular formula; and `mass`, its mass in Dalton.

## (4) Select ions to be quantified

Finally, `ionize()` calculates mass-to-charge ratios of these proteoforms in selected `charge_states`.

```{r}
pfm_ions <-
  pfm_masses %>%
  ionize(charge_states = 33L:40L)

pfm_ions
```

Creating $c$ differently charged ions for $r$ proteoforms yields a data frame with $c \times r$ rows, containing all variables from the input data frame as well as four additional columns: `z` (charge state), `mz` (exact mass-to-charge ratio), `mz_min`, and `mz_max`. The latter two columns represent lower and upper tolerances for the mass-to-charge ratio and will be used as integration boundaries (see below). (The width of this tolerance region is governed by the optional argument `ppm`; see the documentation of `ionize()` for details.)


# Quantify proteoforms

Proteoform quantification requires mass spectrometric data, which can be loaded by `mzR::openMSfile()`. The exemplary file `mab1.mzML` contains mass spectra of a monoclonal antibody.

```{r}
ms_data <- openMSfile(
  system.file("extdata", "mzml", "mab1.mzML", package = "fragquaxi")
)
```

The figure below shows charge states 37+ to 34+ (from left to right) of a representative scan. Each charge state comprises several discernible peaks, each of which corresponds to a single proteoform (or a set of isobaric proteoforms).

```{r warning=FALSE}
sample_spectrum <- spectra(ms_data, 128)
colnames(sample_spectrum) <- c("mz", "intensity")
sample_spectrum %>% 
  as_tibble() %>% 
  ggplot(aes(mz, intensity)) +
  geom_line() +
  xlim(3950, 4400)
```

In order to check whether the previously calculated mass-to-charge ratios match peaks in the mass spectrum, the helper function `plot_ions()` allows you to plot mass spectra overlaid with $m/z$ values and integration boundaries of proteoform ions:

```{r warning=FALSE}
plot_ions(
  ms_data,
  ions = pfm_ions,
  scans = 126:136,      # plot these scans
  xlim = c(4100, 4150)  # zoom into charge state 36+
)
```

Labels on the upper $x$-axis denote proteoform ions, while solid and dashed red lines indicate mass-to-charge ratios and integration boundaries, respectively  

`quantify_ions()` quantifies the previously defined proteoform ions. In the loaded MS data set, only mass spectra that were acquired at retention times between 300 and 350 seconds contain relevant information. Thus, specify these retention time limits *via* the argument `rt_limits`.

```{r}
abundances <- quantify_ions(
  ms_data,
  pfm_ions,
  rt_limits = c(300, 350)
)
```

(`rt_limits` also allows to specify several retention time windows, as described in the documentation.)

Printing the quantification results stored in `abundances` yields a concise summary: 

```{r}
abundances
```

For data analysis, it may be convenient to convert these results to a data frame:

```{r}
as_tibble(abundances)
```

This conversion returns the data frame describing proteoform ions, plus two additional nested columns `abundance_data` and `xic_data`.

* The column `abundance_data` stores data on ion abundances. Each value is a tibble with one row per retention time window (given by the values in columns `rt_min` and `rt_max`); column `abundance` contains corresponding XIC area.

    ```{r}
    abundances %>%
      as_tibble() %>%
      select(modcom_name, z, abundance_data) %>% 
      unnest(abundance_data)
    ```

    Use this data to visualize proteoform abundances:

    ```{r}
    abundances %>%
      as_tibble() %>% 
      unnest(abundance_data) %>% 
      group_by(modcom_name) %>%
      summarise(abundance = sum(abundance)) %>% 
      mutate(frac_ab = abundance / sum(abundance) * 100) %>% 
      ggplot(aes(modcom_name, frac_ab)) +
      geom_col() +
      xlab("") +
      ylab("fractional abundance (%)")
    ```

* The column `xic_data` stores retention times (column `rt`) and intensities (column `int`) of the XIC associated with the respective ion:

    ```{r}
    abundances %>%
      as_tibble() %>%
      select(modcom_name, z, xic_data) %>% 
      unnest(xic_data)
    ```

    Use this data to visualize all XICs:

    ```{r warning=FALSE}
    abundances %>%
      as_tibble() %>%
      unnest(xic_data) %>%
      ggplot(aes(rt, int)) +
      geom_line(aes(color = factor(z))) +
      facet_wrap(vars(modcom_name)) +
      xlab("retention time (s)") +
      ylab("intensity (AU)") +
      xlim(300, 350) +
      theme_bw()
    ```



# Working with several MS files

Ions may also be quantified in a batch of MS files, and the resulting abundances may be used to calculate summary statistics.

```{r}
ms_files <-
  system.file("extdata", "mzml", package = "fragquaxi") %>% 
  list.files(pattern = "mab\\d", full.names = TRUE)

all_abundances <-
  map_dfr(
    ms_files,
    function(file) {
      ms_file <- openMSfile(file)
      xic <- quantify_ions(ms_file, pfm_ions, rt_limits = c(300, 350))
      xic %>%
        as_tibble() %>%
        unnest(abundance_data) %>%
        group_by(modcom_name) %>%
        summarise(abundance = sum(abundance)) %>%
        mutate(abundance = abundance / sum(abundance) * 100)
    },
    .id = "sample"
  )

all_abundances
```

The following bar chart displays ion abundances in each sample:

```{r}
all_abundances %>%
  ggplot(aes(sample, abundance)) +
  geom_col(aes(fill = modcom_name), position = "dodge") +
  ylab("fractional abundance (%)")
```

Since the three MS data files correspond to replicates, calculate mean proteoform abundances and their standard deviations:

```{r}
all_abundances %>%
  group_by(modcom_name) %>%
  summarise(mean = mean(abundance), sd = sd(abundance)) %>%
  ggplot(aes(modcom_name, mean)) +
  geom_col(aes(fill = modcom_name), show.legend = FALSE) +
  geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd), width = .5) +
  ylab("fractional abundance (%)")
```


# Direct infusion

In certain experiments (e.g., direct infusion with rolling averaging), it may be sensible to quantify proteoforms by integrating a single mass spectrum instead of an XIC. `fragquaxi` also facilitates this approach, since each intensity value in the XIC data reported by `quantify_ions(...) %>% as_table()` corresponds to the abundance of an ion in a single spectrum.

Below, we load a series of 105 spectra from a direct infusion measurement of NISTmAb and define proteoforms to be quantified in charge states 24+ to 30+:

```{r}
di_data <- openMSfile(
  system.file("extdata", "mzml", "mab_di.mzML", package = "fragquaxi")
)

nistmab <- tibble(
  protein_name = "nistmab",
  protein_formula = molecular_formula("C6464 H9984 N1700 O2006 S48")
)

nistmab_modcoms <- tribble(
  ~modcom_name,     ~Hex, ~HexNAc, ~Fuc, 
  "A2G0F/A2G0F",       6,        8,   2, 
  "A2G0F/A2G1F",       7,        8,   2, 
  "A2G1F/A2G1F",       8,        8,   2, 
  "A2G1F/A2G2F",       9,        8,   2,
  "A2G2F/A2G2F",      10,        8,   2, 
  "A2G2F/A2G2F+1Hex", 11,        8,   2, 
  "A1G0F/A2G0F",       6,        7,   2
) %>% 
  define_ptm_compositions()

di_ions <- 
  assemble_proteoforms(nistmab, nistmab_modcoms) %>% 
  ionize(24L:30L)
```

Since these spectra were obtained by rolling averaging, it is sufficient to quantify proteoforms in the last recorded spectrum, where most of the noise has been eliminated.

```{r}
plot_ions(di_data, di_ions, scans = c(1, 105), xlim = c(5450, 5550)) +
  facet_wrap(
    vars(scan),
    ncol = 1,
    strip.position = "right",
    scales = "free_y"
  )
```

(Note how the plot returned by `plot_ions()` may be further customized *via* the usual `ggplot2` syntax – here, a facet specification is included.)

Following quantification, obtain XIC data and filter for the last scan number:

```{r}
di_abundances <- 
  di_data %>%
  quantify_ions(di_ions) %>% 
  as_tibble(abundance_col = NULL) %>% 
  unnest(xic_data) %>%
  filter(scan == max(scan))

di_abundances
```

The values in column `int` represent proteoform ion abundances in the last scan.

```{r}
di_abundances %>% 
  group_by(modcom_name) %>% 
  summarise(abundance = sum(int)) %>%
  mutate(abundance = abundance / sum(abundance) * 100)
```
